# -*- coding: utf-8 -*-
"""Maze BFS, and FIFO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jYMGQPdrDVnbdhzddMCAZg2ijJdKaZPa
"""

#Here I'll be doing a code that finds the shortest path to get to the end of a maze using bfs.
# Here I got a maze list that will present the maze structre.
# My S is my starting point and my X is my ending point.
# The hashtags are barriers and the empty coordinates will be paths that may or may not lead to the ending.
from queue import Queue

maze = [
    ["#","#", "S", "#", "#", "#", "#", "#","#", "#", "#", "#", "#"],
    ["#","#", " ", "#", " ", "#", "#", "#","#", " ", " ", " ", "#"],
    ["#","#", " ", " ", " ", "#", " ", " "," ", " ", "#", " ", "#"],
    ["#","#", " ", "#", " ", " ", " ", "#"," ", "#", "#", " ", "#"],
    ["#"," ", " ", "#", " ", "#", "#", "#"," ", "#", "#", " ", "#"],
    ["#"," ", "#", "#", " ", " ", "#", " "," ", "#", " ", " ", "#"],
    ["#"," ", " ", "#", "#", " ", "#", " ","#", "#", "#", " ", "#"],
    ["#","#", " ", "#", " ", " ", " ", " "," ", " ", "#", " ", "#"],
    ["#","#", " ", "#", " ", "#", " ", "#","#", " ", "#", "#", "#"],
    ["#","#", " ", " ", " ", "#", " ", "#","#", " ", "#", "#", "#"],
    ["#","#", " ", "#", "#", "#", "X", "#","#", " ", " ", "#", "#"],
    ["#","#", "#", "#", "#", "#", "#", "#","#", "#", "#", "#", "#"]
]

def display_maze(maze):#We want to get each element of the row and append it to the maze_row variable and display the row
  for row in maze:
      maze_row = ""
      for coordinate in row:
        maze_row += " " + coordinate
      print(maze_row)

def find_node(maze, node):
  row_size = len(maze[0]) #counts the maze size once
  maze_size = len(maze)

  for row in range(maze_size): #re calculating the length of the maze each time we go through an iteration
    for col in range(row_size):
      if maze[row][col] == node:
        return row, col

def transform_to_graph(maze):
  graph = {}
  maze_size = len(maze)
  row_size = len(maze[0])
  for row in range(maze_size):
    for col in range(row_size):
      if maze[row][col] != '#':
        adj_nodes = []
        if row+1 < maze_size and maze[row+1][col] != '#':#Move down
          adj_nodes.append((row+1, col))
        if row-1 >= 0 and maze[row-1][col] != '#':#Move Up
          adj_nodes.append((row-1, col))
        if col+1 < row_size and maze[row][col+1] != '#':#Move Right
          adj_nodes.append((row, col+1))
        if col-1 >= 0 and maze[row][col-1] != '#':#Move Left
          adj_nodes.append((row,col-1))

        graph[(row,col)]= adj_nodes
  return graph

def solve_maze(maze, maze_graph, start_node, finish_node):
  visited = [] #helps us make sure we don't visit a node more than once
  start_path = [start_node]
  q = Queue()
  q.put(start_path)

  while not q.empty(): #remove elements from. the queue and store them in path
    path = q.get()
    neighbours = maze_graph[path[-1]] #getting the neighbors of the last node of the path and process the neighbors

    for n in neighbours:
      if n == finish_node:
        for coordinate in path:
          row, col = coordinate
          maze[row][col] = 'P' #denoting the path in the maze by writing x's in those coordinates
        return maze #return the solved maze

      if n not in visited:
        visited.append(n) #helps us not visit it again and continue
        new_path = path + [n]
        q.put(new_path)


start_node = find_node(maze, "S")
finish_node = find_node(maze, "X")
maze_graph = transform_to_graph(maze)
solved_maze = solve_maze(maze, maze_graph, start_node, finish_node)
print(start_node, finish_node)

display_maze(maze) #Call the display function to print the maze